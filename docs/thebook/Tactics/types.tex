\chapter{Sets vs types}\label{chap:setsvstypes}
\cite{Nederpelt:2014aa}
\cite{Girard:1989aa}
\section{Types}\label{sec:types}
This is a rather subtle section. It deals with a primitive notion in Automated Theorem Provers, the concept of type. Reading through the book you might have wondered about the occurrence of things like this:

\coq{P:Prop\\ Q:Prop\\ H:P->Q}{\cdots}

The notation seems to be similar for $P:Prop$ and for $Hyp:P->Q$.

Let us try some experiments. We first define some variables: P and Q will be propositions and h ``will be` in $P\rightarrow Q$''

\inp{Variable P Prop. Variable Q:Prop.\\Variable h:P->Q.}

Now let us check them, 
\inp{Check P.\\
Check (P->Q)}

Nor surprises there, we get $P:Prop$ and ``$P \rightarrow Q : Prop$''
Now try
\inp{Check h.}

The result is \mess{$h
     : P \rightarrow Q$. }
     
Note that, in particular h is NOT a proposition but an object of type $P->Q$, I.e. a witness(proof) of the implication $P->Q$. Similarly if you define 
\inp{Axiom aaa:2=1+1.}then \inp{Check aaa.} will produce
\mess{aaa
     : 2 = 1 + 1}
That means that aaa is a witness of the equality $2=1+1$ and that you can refer to aaa in other proofs (for example using rewrite). You can also show for example that there is only one proof of the fact that 2=2+1.




 For much of the book one can look at the notation $a:nat$ as a SpatchCoq version of $a\in \mathbb{N}$. This is not quite correct. In fact $a:U$ denotes the statement ``a is of type U''. In particular, the notation $Hyp:P\rightarrow Q$ and $P:Prop$ have the same kind of meaning. The first one means that Hyp is an object of the type $P\rightarrow Q$ i.e a witness of a proof of $P\rightarrow Q$ while the second means that $P$ is an object of type $Prop$.

The point is that types are primitive objects in Coq (hence in SpatchCoq) and, more importantly, 

{\bf \Large Types are not Sets!}

In Coq (and SpatchCoq) every object has a unique type. For example, 0 cannot represent both the natural number zero and the integer zero. The two objects are different and you need a conversion between them. try for example:
\inp{Check 0.}
\inp{Check 0\%Z.}




Now consider the following:

\inp{Check Type.}

you get ``Type: Type''!!!!! What does that even mean? It seems that Type is of type Type, surely this must be some sort of Russell paradox.

This is in some sense, the crux of the matter. Modern type theory evolved out of an attempt, 
by Russell himself, to resolve the paradoxes of Set Theory. This was surpassed in popularity by the ZF Axiomatic Set Theory and waited, half forgotten, for Computer Scientists to rediscover it. The type system of Coq(and SpatchCoq) is based 

In fact, the notation ``$Type : Type$'' is a small notational abuse. It really means that $Type_{0} : Type_{1}$ or, more generally $Type_{n} : Type_{n+1}$. This is exactly how Russell imagined types,  as an infinite series. At the bottom there are sets, that is types like nat or $\mathbb{Z}$ or bool or nat->nat. They are themselves types of type Set. The next layer is made of Set itself which of type Type$(_{0})$ is the type Prop. $Typ_{0}$ is itself an object which is of type $Type_{1}$ and so on. Note for example:

\inp{Check Type:Type} which produces:
$Type : Type
     : Type$.
 There are also wonderfully confusing statements in type theory. For example, consider  two proofs of ``0=0'', the absolutely trivial one:
\inp{Lemma a:0=0.\\
This follows from reflexivity.\\
Qed.}

And a bizarre one:
\inp{
Lemma b:0=0.\\
Claim (1=1).\\
This follows from reflexivity.\\
Apply result eq\_add\_S.\\
This follows from assumptions.
Qed.}
They do turn out to be the same proof? Let us look at the  module Eqdep\_dec and the lemma eq\_proofs\_unicity\_on: 

Theorem eq\_proofs\_unicity\_on :$ \forall (y:A) (p1 p2:x = y), p1 = p2.$

It seems to be saying that any two proofs of an equality are the same. Cool let us use it.
\inp{
Require Import Eqdep\_dec.
Lemma c:a=b.
Apply result eq\_proofs\_unicity\_on.}

Surprisingly we get:

\coq{ }{\forall y : nat, (0 = y) \lor (not (0 = y)))}

Which is a bit noting, in fact, the theorem in the story is true if equality id decidable in the type $A$. Luckily in nat it is:
\inp{
Fix an arbitrary element y.\\
Apply induction on y.\\
Prove left hand side.\\
This follows from reflexivity.\\
Consider cases based on disjunction in hypothesis IHy.\\
Prove right hand side.\\
Replace y by 0 in the goal.\\
This is trivial.\\
Prove right hand side.\\
Rewrite goal using the definition of not.\\
Apply result O\_S.\\
Qed.}

However if we consider functions $nat \rightarrow nat$ the story is a bit different even if we use identically looking functions.
\inp{
Definition f:nat->nat:=fun x$\Rightarrow$x.\\
Lemma a:f=f.\\
This follows from reflexivity.\\
Qed.\\
Lemma b: f=f.\\
This follows from reflexivity.\\
Qed.\\
Require Import Eqdep\_dec.\\
Lemma c :a=b.\\
Apply result eq\_proofs\_unicity\_on.}
Gives

\coq{ }{(\forall (y : nat) \rightarrow nat, (f = y) \lor (not (f = y)))}

Which is not decidable so we can only prove it in classical logic and not in constructive logic. 

     
    

     
     